<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.5" />
<title>aiger_bv.expr API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aiger_bv.expr</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
from functools import partial, reduce
from typing import Union

import attr
import funcy as fn

from aiger_bv import common as cmn
from aiger_bv import aigbv
from aiger_bv.bundle import Bundle


def constk(k, size=None):
    def _constk(expr):
        nonlocal size
        if size is None:
            size = expr.size
        return cmn.source(size, k, signed=False) \
            | cmn.sink(expr.size, expr.inputs)
    return _constk


def _encoded_inputs(expr, inputs):
    if inputs is None:
        inputs = {}

    signed = isinstance(expr, SignedBVExpr)
    imap = expr.aigbv.imap

    for key, val in inputs.items():
        if isinstance(val, int) and (key in expr.inputs):
            size = imap[key].size
            val = cmn.encode_int(size, val, signed=signed)
        yield key, val


@attr.s(frozen=True, slots=True, eq=False, auto_attribs=True)
class UnsignedBVExpr:
    aigbv: aigbv.AIGBV

    def __call__(self, inputs=None):
        inputs = dict(_encoded_inputs(self, inputs))
        return self.aigbv(inputs)[0][self.output]

    def __getitem__(self, idx: Union[int, slice]):
        # TODO: support slice steps.
        def _indexer(idx):
            gate = cmn.index_gate(self.size, idx, self.output, cmn._fresh())
            return UnsignedBVExpr(self.aigbv &gt;&gt; gate)

        if isinstance(idx, int):
            if abs(idx) &gt;= self.size:
                raise ValueError(
                    &#39;Index %d out of range (BV size %d).&#39; % (idx, self.size))
            idx = idx % self.size
        if not isinstance(idx, slice):
            idx = slice(idx, idx+1)
        if idx.start is None:
            idx = slice(0, idx.stop)
        if idx.stop is None:
            idx = slice(idx.start, self.size)
        if idx.step is not None:
            raise NotImplementedError

        assert 0 &lt;= idx.start &lt; idx.stop &lt;= self.size
        indicies = list(range(idx.start, idx.stop))

        if len(indicies) == 1:
            return _indexer(indicies[0])

        indexers = map(_indexer, indicies)
        return reduce(lambda x, y: x.concat(y), indexers)

    def bundle_inputs(self, name=None, order=None):
        if name is None:
            name = cmn._fresh()
        if order is None:
            order = self.inputs

        size = sum(self.aigbv.imap.values())
        bdl = Bundle(name=name, size=size)
        inputs = fn.lconcat(*(self.aigbv.imap[i] for i in order))

        relabels = {old: new for old, new in zip(inputs, bdl)}
        circ = aigbv.rebundle_aig(self.aig[&#39;i&#39;, relabels])
        return attr.evolve(self, aigbv=circ)

    def concat(self, other):
        combiner = cmn.combine_gate(
            output=cmn._fresh(),
            left_wordlen=self.size, left=self.output,
            right_wordlen=other.size, right=other.output,
        )
        circ = self.aigbv | other.aigbv
        return type(self)(circ &gt;&gt; combiner)

    def repeat(self, times):
        # TODO: support size != 1 via self concatenation.
        assert self.size == 1
        repeater = cmn.repeat(times, self.output, cmn._fresh())
        return type(self)(self.aigbv &gt;&gt; repeater)

    @property
    def output(self):
        return fn.first(self.aigbv.outputs)

    @property
    def inputs(self):
        return self.aigbv.inputs

    @property
    def size(self):
        return fn.first(self.aigbv.omap.values())

    @property
    def aig(self):
        return self.aigbv.aig

    def __invert__(self):
        return _unary_gate(cmn.bitwise_negate, self)

    def __lshift__(self, n_bits):
        return _shift_gate(cmn.left_shift_gate, self, n_bits)

    def __rshift__(self, n_bits):
        return _shift_gate(cmn.logical_right_shift_gate, self, n_bits)

    def __add__(self, other):
        return _binary_gate(cmn.add_gate, self, other, lambda x: x)

    def __sub__(self, other):
        return _binary_gate(cmn.subtract_gate, self, other, constk(0))

    def __and__(self, other):
        return _binary_gate(cmn.bitwise_and, self, other, lambda x: x)

    def __matmul__(self, other):
        return _binary_gate(
            cmn.dot_mod2_gate, self, other,
            lambda e: _unary_gate(cmn.even_popcount_gate, e).aigbv
        )

    def __or__(self, other):
        return _binary_gate(cmn.bitwise_or, self, other, lambda x: x)

    def __xor__(self, other):
        return _binary_gate(cmn.bitwise_xor, self, other, constk(0))

    def __ne__(self, other):
        return _binary_gate(cmn.ne_gate, self, other, constk(0, 1))

    def __eq__(self, other):
        return ~(self != other)

    def __le__(self, other):
        return _binary_gate(cmn.unsigned_le_gate, self, other, constk(1, 1))

    def __ge__(self, other):
        return _binary_gate(cmn.unsigned_ge_gate, self, other, constk(1, 1))

    def __lt__(self, other):
        return ~(self &gt;= other)

    def __gt__(self, other):
        return ~(self &lt;= other)

    def __abs__(self):
        return self

    def with_output(self, val):
        if val == self.output:
            return self
        return attr.evolve(self, aigbv=self.aigbv[&#39;o&#39;, {self.output: val}])

    def _fresh_output(self):
        return self.with_output(cmn._fresh())

    def __mul__(self, other):
        if isinstance(other, int):
            signed = isinstance(self, SignedBVExpr)

            size = math.ceil(math.log2(abs(other) + 1))
            size += int(signed)  # Signed has double the range.

            other = atom(size, other, signed=signed)

        if isinstance(other, SignedBVExpr) != isinstance(self, SignedBVExpr):
            raise ValueError(&#39;Cannot multiply signed with unsigned integers.&#39;)

        # Determine the smaller circuit to minimize worst-case depth.
        smaller, larger = sorted([self, other], key=lambda x: x.size)
        result = atom(larger.size, 0, signed=isinstance(self, SignedBVExpr))
        for i in range(smaller.size):
            mask = smaller[i].repeat(larger.size)
            delta = mask &amp; (larger &lt;&lt; i)

            # For signed multiplication, need to subtract the last index.
            subtract = i == smaller.size - 1 and isinstance(self, SignedBVExpr)
            if subtract:
                result -= delta
            else:
                result += delta
        return result


class SignedBVExpr(UnsignedBVExpr):
    def __neg__(self):
        return _unary_gate(cmn.negate_gate, self)

    def __le__(self, other):
        return _binary_gate(cmn.signed_le_gate, self, other, constk(1, 1))

    def __ge__(self, other):
        return _binary_gate(cmn.signed_ge_gate, self, other, constk(1, 1))

    def __rshift__(self, n_bits):
        return _shift_gate(cmn.arithmetic_right_shift_gate, self, n_bits)

    def __abs__(self):
        return _unary_gate(cmn.abs_gate, self)

    def sign(self):
        return UnsignedBVExpr(self.aigbv)[-1]


Expr = Union[UnsignedBVExpr, SignedBVExpr]


def _shift_gate(gate, expr, n_bits):
    return _unary_gate(gate=partial(gate, shift=n_bits), expr=expr)


def _binary_gate(gate, expr1, expr2, same_circ=None):
    if isinstance(expr2, int):
        expr2 = atom(expr1.size, expr2, signed=isinstance(expr1, SignedBVExpr))

    assert expr1.size == expr2.size
    if expr1.aigbv == expr2.aigbv and same_circ is not None:
        return type(expr1)(same_circ(expr1))
    elif expr1.aigbv.aig.outputs &amp; expr2.aigbv.aig.outputs:
        expr2 = expr2._fresh_output()

    circ3 = expr1.aigbv | expr2.aigbv
    circ3 &gt;&gt;= gate(wordlen=expr1.size, output=cmn._fresh(),
                   left=expr1.output, right=expr2.output)
    return type(expr1)(aigbv=circ3)


def _unary_gate(gate, expr):
    circ = gate(expr.size, input=expr.output, output=cmn._fresh())
    return type(expr)(aigbv=expr.aigbv &gt;&gt; circ)


def ite(test, expr_true, expr_false):
    assert test.size == 1
    assert expr_true.size == expr_false.size
    test = test.repeat(expr_true.size)
    return (~test | expr_true) &amp; (test | expr_false)


Val = Union[str, int, None]


def atom(wordlen: int, val: Val, signed: bool = True) -&gt; Expr:
    output = cmn._fresh()
    if val is None:
        val = cmn._fresh()

    if isinstance(val, str):
        aig = cmn.identity_gate(wordlen, val, output)
    else:
        aig = cmn.source(wordlen, val, output, signed)

    return (SignedBVExpr if signed else UnsignedBVExpr)(aig)


def uatom(wordlen: int, val: Val) -&gt; Expr:
    return atom(wordlen, val, signed=False)


__all__ = [&#39;atom&#39;, &#39;uatom&#39;, &#39;UnsignedBVExpr&#39;, &#39;SignedBVExpr&#39;, &#39;ite&#39;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aiger_bv.expr.atom"><code class="name flex">
<span>def <span class="ident">atom</span></span>(<span>wordlen: int, val: Union[str, int, NoneType], signed: bool = True) ‑> Union[<a title="aiger_bv.expr.UnsignedBVExpr" href="#aiger_bv.expr.UnsignedBVExpr">UnsignedBVExpr</a>, <a title="aiger_bv.expr.SignedBVExpr" href="#aiger_bv.expr.SignedBVExpr">SignedBVExpr</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atom(wordlen: int, val: Val, signed: bool = True) -&gt; Expr:
    output = cmn._fresh()
    if val is None:
        val = cmn._fresh()

    if isinstance(val, str):
        aig = cmn.identity_gate(wordlen, val, output)
    else:
        aig = cmn.source(wordlen, val, output, signed)

    return (SignedBVExpr if signed else UnsignedBVExpr)(aig)</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.ite"><code class="name flex">
<span>def <span class="ident">ite</span></span>(<span>test, expr_true, expr_false)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ite(test, expr_true, expr_false):
    assert test.size == 1
    assert expr_true.size == expr_false.size
    test = test.repeat(expr_true.size)
    return (~test | expr_true) &amp; (test | expr_false)</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.uatom"><code class="name flex">
<span>def <span class="ident">uatom</span></span>(<span>wordlen: int, val: Union[str, int, NoneType]) ‑> Union[<a title="aiger_bv.expr.UnsignedBVExpr" href="#aiger_bv.expr.UnsignedBVExpr">UnsignedBVExpr</a>, <a title="aiger_bv.expr.SignedBVExpr" href="#aiger_bv.expr.SignedBVExpr">SignedBVExpr</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uatom(wordlen: int, val: Val) -&gt; Expr:
    return atom(wordlen, val, signed=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aiger_bv.expr.SignedBVExpr"><code class="flex name class">
<span>class <span class="ident">SignedBVExpr</span></span>
<span>(</span><span>aigbv: <a title="aiger_bv.aigbv.AIGBV" href="aigbv.html#aiger_bv.aigbv.AIGBV">AIGBV</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class UnsignedBVExpr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignedBVExpr(UnsignedBVExpr):
    def __neg__(self):
        return _unary_gate(cmn.negate_gate, self)

    def __le__(self, other):
        return _binary_gate(cmn.signed_le_gate, self, other, constk(1, 1))

    def __ge__(self, other):
        return _binary_gate(cmn.signed_ge_gate, self, other, constk(1, 1))

    def __rshift__(self, n_bits):
        return _shift_gate(cmn.arithmetic_right_shift_gate, self, n_bits)

    def __abs__(self):
        return _unary_gate(cmn.abs_gate, self)

    def sign(self):
        return UnsignedBVExpr(self.aigbv)[-1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="aiger_bv.expr.UnsignedBVExpr" href="#aiger_bv.expr.UnsignedBVExpr">UnsignedBVExpr</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aiger_bv.expr.SignedBVExpr.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self):
    return UnsignedBVExpr(self.aigbv)[-1]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="aiger_bv.expr.UnsignedBVExpr" href="#aiger_bv.expr.UnsignedBVExpr">UnsignedBVExpr</a></b></code>:
<ul class="hlist">
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.aigbv" href="#aiger_bv.expr.UnsignedBVExpr.aigbv">aigbv</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr"><code class="flex name class">
<span>class <span class="ident">UnsignedBVExpr</span></span>
<span>(</span><span>aigbv: <a title="aiger_bv.aigbv.AIGBV" href="aigbv.html#aiger_bv.aigbv.AIGBV">AIGBV</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Method generated by attrs for class UnsignedBVExpr.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnsignedBVExpr:
    aigbv: aigbv.AIGBV

    def __call__(self, inputs=None):
        inputs = dict(_encoded_inputs(self, inputs))
        return self.aigbv(inputs)[0][self.output]

    def __getitem__(self, idx: Union[int, slice]):
        # TODO: support slice steps.
        def _indexer(idx):
            gate = cmn.index_gate(self.size, idx, self.output, cmn._fresh())
            return UnsignedBVExpr(self.aigbv &gt;&gt; gate)

        if isinstance(idx, int):
            if abs(idx) &gt;= self.size:
                raise ValueError(
                    &#39;Index %d out of range (BV size %d).&#39; % (idx, self.size))
            idx = idx % self.size
        if not isinstance(idx, slice):
            idx = slice(idx, idx+1)
        if idx.start is None:
            idx = slice(0, idx.stop)
        if idx.stop is None:
            idx = slice(idx.start, self.size)
        if idx.step is not None:
            raise NotImplementedError

        assert 0 &lt;= idx.start &lt; idx.stop &lt;= self.size
        indicies = list(range(idx.start, idx.stop))

        if len(indicies) == 1:
            return _indexer(indicies[0])

        indexers = map(_indexer, indicies)
        return reduce(lambda x, y: x.concat(y), indexers)

    def bundle_inputs(self, name=None, order=None):
        if name is None:
            name = cmn._fresh()
        if order is None:
            order = self.inputs

        size = sum(self.aigbv.imap.values())
        bdl = Bundle(name=name, size=size)
        inputs = fn.lconcat(*(self.aigbv.imap[i] for i in order))

        relabels = {old: new for old, new in zip(inputs, bdl)}
        circ = aigbv.rebundle_aig(self.aig[&#39;i&#39;, relabels])
        return attr.evolve(self, aigbv=circ)

    def concat(self, other):
        combiner = cmn.combine_gate(
            output=cmn._fresh(),
            left_wordlen=self.size, left=self.output,
            right_wordlen=other.size, right=other.output,
        )
        circ = self.aigbv | other.aigbv
        return type(self)(circ &gt;&gt; combiner)

    def repeat(self, times):
        # TODO: support size != 1 via self concatenation.
        assert self.size == 1
        repeater = cmn.repeat(times, self.output, cmn._fresh())
        return type(self)(self.aigbv &gt;&gt; repeater)

    @property
    def output(self):
        return fn.first(self.aigbv.outputs)

    @property
    def inputs(self):
        return self.aigbv.inputs

    @property
    def size(self):
        return fn.first(self.aigbv.omap.values())

    @property
    def aig(self):
        return self.aigbv.aig

    def __invert__(self):
        return _unary_gate(cmn.bitwise_negate, self)

    def __lshift__(self, n_bits):
        return _shift_gate(cmn.left_shift_gate, self, n_bits)

    def __rshift__(self, n_bits):
        return _shift_gate(cmn.logical_right_shift_gate, self, n_bits)

    def __add__(self, other):
        return _binary_gate(cmn.add_gate, self, other, lambda x: x)

    def __sub__(self, other):
        return _binary_gate(cmn.subtract_gate, self, other, constk(0))

    def __and__(self, other):
        return _binary_gate(cmn.bitwise_and, self, other, lambda x: x)

    def __matmul__(self, other):
        return _binary_gate(
            cmn.dot_mod2_gate, self, other,
            lambda e: _unary_gate(cmn.even_popcount_gate, e).aigbv
        )

    def __or__(self, other):
        return _binary_gate(cmn.bitwise_or, self, other, lambda x: x)

    def __xor__(self, other):
        return _binary_gate(cmn.bitwise_xor, self, other, constk(0))

    def __ne__(self, other):
        return _binary_gate(cmn.ne_gate, self, other, constk(0, 1))

    def __eq__(self, other):
        return ~(self != other)

    def __le__(self, other):
        return _binary_gate(cmn.unsigned_le_gate, self, other, constk(1, 1))

    def __ge__(self, other):
        return _binary_gate(cmn.unsigned_ge_gate, self, other, constk(1, 1))

    def __lt__(self, other):
        return ~(self &gt;= other)

    def __gt__(self, other):
        return ~(self &lt;= other)

    def __abs__(self):
        return self

    def with_output(self, val):
        if val == self.output:
            return self
        return attr.evolve(self, aigbv=self.aigbv[&#39;o&#39;, {self.output: val}])

    def _fresh_output(self):
        return self.with_output(cmn._fresh())

    def __mul__(self, other):
        if isinstance(other, int):
            signed = isinstance(self, SignedBVExpr)

            size = math.ceil(math.log2(abs(other) + 1))
            size += int(signed)  # Signed has double the range.

            other = atom(size, other, signed=signed)

        if isinstance(other, SignedBVExpr) != isinstance(self, SignedBVExpr):
            raise ValueError(&#39;Cannot multiply signed with unsigned integers.&#39;)

        # Determine the smaller circuit to minimize worst-case depth.
        smaller, larger = sorted([self, other], key=lambda x: x.size)
        result = atom(larger.size, 0, signed=isinstance(self, SignedBVExpr))
        for i in range(smaller.size):
            mask = smaller[i].repeat(larger.size)
            delta = mask &amp; (larger &lt;&lt; i)

            # For signed multiplication, need to subtract the last index.
            subtract = i == smaller.size - 1 and isinstance(self, SignedBVExpr)
            if subtract:
                result -= delta
            else:
                result += delta
        return result</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="aiger_bv.expr.SignedBVExpr" href="#aiger_bv.expr.SignedBVExpr">SignedBVExpr</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="aiger_bv.expr.UnsignedBVExpr.aig"><code class="name">var <span class="ident">aig</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aig(self):
    return self.aigbv.aig</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.aigbv"><code class="name">var <span class="ident">aigbv</span> : <a title="aiger_bv.aigbv.AIGBV" href="aigbv.html#aiger_bv.aigbv.AIGBV">AIGBV</a></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.inputs"><code class="name">var <span class="ident">inputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inputs(self):
    return self.aigbv.inputs</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.output"><code class="name">var <span class="ident">output</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output(self):
    return fn.first(self.aigbv.outputs)</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    return fn.first(self.aigbv.omap.values())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aiger_bv.expr.UnsignedBVExpr.bundle_inputs"><code class="name flex">
<span>def <span class="ident">bundle_inputs</span></span>(<span>self, name=None, order=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bundle_inputs(self, name=None, order=None):
    if name is None:
        name = cmn._fresh()
    if order is None:
        order = self.inputs

    size = sum(self.aigbv.imap.values())
    bdl = Bundle(name=name, size=size)
    inputs = fn.lconcat(*(self.aigbv.imap[i] for i in order))

    relabels = {old: new for old, new in zip(inputs, bdl)}
    circ = aigbv.rebundle_aig(self.aig[&#39;i&#39;, relabels])
    return attr.evolve(self, aigbv=circ)</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(self, other):
    combiner = cmn.combine_gate(
        output=cmn._fresh(),
        left_wordlen=self.size, left=self.output,
        right_wordlen=other.size, right=other.output,
    )
    circ = self.aigbv | other.aigbv
    return type(self)(circ &gt;&gt; combiner)</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.repeat"><code class="name flex">
<span>def <span class="ident">repeat</span></span>(<span>self, times)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def repeat(self, times):
    # TODO: support size != 1 via self concatenation.
    assert self.size == 1
    repeater = cmn.repeat(times, self.output, cmn._fresh())
    return type(self)(self.aigbv &gt;&gt; repeater)</code></pre>
</details>
</dd>
<dt id="aiger_bv.expr.UnsignedBVExpr.with_output"><code class="name flex">
<span>def <span class="ident">with_output</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_output(self, val):
    if val == self.output:
        return self
    return attr.evolve(self, aigbv=self.aigbv[&#39;o&#39;, {self.output: val}])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aiger_bv" href="index.html">aiger_bv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aiger_bv.expr.atom" href="#aiger_bv.expr.atom">atom</a></code></li>
<li><code><a title="aiger_bv.expr.ite" href="#aiger_bv.expr.ite">ite</a></code></li>
<li><code><a title="aiger_bv.expr.uatom" href="#aiger_bv.expr.uatom">uatom</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aiger_bv.expr.SignedBVExpr" href="#aiger_bv.expr.SignedBVExpr">SignedBVExpr</a></code></h4>
<ul class="">
<li><code><a title="aiger_bv.expr.SignedBVExpr.sign" href="#aiger_bv.expr.SignedBVExpr.sign">sign</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aiger_bv.expr.UnsignedBVExpr" href="#aiger_bv.expr.UnsignedBVExpr">UnsignedBVExpr</a></code></h4>
<ul class="two-column">
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.aig" href="#aiger_bv.expr.UnsignedBVExpr.aig">aig</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.aigbv" href="#aiger_bv.expr.UnsignedBVExpr.aigbv">aigbv</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.bundle_inputs" href="#aiger_bv.expr.UnsignedBVExpr.bundle_inputs">bundle_inputs</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.concat" href="#aiger_bv.expr.UnsignedBVExpr.concat">concat</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.inputs" href="#aiger_bv.expr.UnsignedBVExpr.inputs">inputs</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.output" href="#aiger_bv.expr.UnsignedBVExpr.output">output</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.repeat" href="#aiger_bv.expr.UnsignedBVExpr.repeat">repeat</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.size" href="#aiger_bv.expr.UnsignedBVExpr.size">size</a></code></li>
<li><code><a title="aiger_bv.expr.UnsignedBVExpr.with_output" href="#aiger_bv.expr.UnsignedBVExpr.with_output">with_output</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.5</a>.</p>
</footer>
</body>
</html>